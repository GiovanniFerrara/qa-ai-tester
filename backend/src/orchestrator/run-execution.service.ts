import { Injectable, Logger } from '@nestjs/common';
import { readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { v4 as uuidv4 } from 'uuid';

import type { Finding, QaReport, TaskSpec } from '../models/contracts';
import type { AiProvider, RunResult } from '../models/run';
import { AiProviderRegistryService } from '../providers/ai-provider-registry.service';
import { ComputerUseOrchestratorService } from '../providers/computer-use-orchestrator.service';
import { RunEventsService } from './run-events.service';
import { WorkerGatewayService } from '../worker/worker-gateway.service';

@Injectable()
export class RunExecutionService {
  private readonly logger = new Logger(RunExecutionService.name);

  constructor(
    private readonly providerRegistry: AiProviderRegistryService,
    private readonly workerGateway: WorkerGatewayService,
    private readonly computerUseOrchestratorService: ComputerUseOrchestratorService,
    private readonly runEvents: RunEventsService,
  ) {}

  async execute(runId: string, task: TaskSpec, providerKey: AiProvider): Promise<RunResult> {
    const startedAt = new Date();
    const provider = this.providerRegistry.resolve(providerKey);
    this.logger.log(
      `Starting run ${runId} with task ${task.id} using provider ${provider.provider}`,
    );

    const handle = await this.workerGateway.startRun(runId, task.route);
    this.runEvents.emit(runId, {
      type: 'status',
      message: `Run ${runId} started`,
      timestamp: startedAt.toISOString(),
      payload: { taskId: task.id },
    });

    try {
      const initialScreenshot = await this.workerGateway.captureScreenshot(handle, 'initial');
      try {
        const screenshotBuffer = await readFile(initialScreenshot);
        this.runEvents.emit(runId, {
          type: 'screenshot',
          message: 'Initial viewport capture',
          timestamp: new Date().toISOString(),
          payload: {
            image: `data:image/png;base64,${screenshotBuffer.toString('base64')}`,
            path: initialScreenshot,
          },
        });
      } catch (error) {
        this.logger.warn(
          `Failed to read initial screenshot for streaming: ${(error as Error).message}`,
        );
      }
      let report: QaReport | null = null;
      let eventsPath: string | undefined;
      let responsesPath: string | undefined;
      let usageTotals = { tokensInput: 0, tokensOutput: 0, totalTokens: 0 };
      let totalToolCalls = 0;
      let modelUsed: string | null = null;
      let errorDuringRun: Error | null = null;

      try {
        const sessionResult = await this.computerUseOrchestratorService.run({
          provider: provider.provider,
          runId,
          task,
          handle,
          initialScreenshotPath: initialScreenshot,
          startedAt,
        });
        report = sessionResult.report;
        eventsPath = sessionResult.eventsPath;
        responsesPath = sessionResult.responsesPath;
        usageTotals = sessionResult.usageTotals;
        totalToolCalls = sessionResult.totalToolCalls;
        modelUsed = sessionResult.model ?? null;
      } catch (error) {
        errorDuringRun = error as Error;
        this.logger.error(
          `Computer-use session failed for run ${runId}: ${(error as Error).message}`,
        );
        this.runEvents.emit(runId, {
          type: 'status',
          message: `Computer-use session error: ${(error as Error).message}`,
          timestamp: new Date().toISOString(),
        });
      }

      const finishedAt = new Date();
      const tracePath = path.join(handle.artifactDir, 'trace.zip');

      if (!report) {
        report = this.buildFallbackReport({
          runId,
          task,
          startedAt,
          finishedAt,
          initialScreenshot,
          tracePath,
          reason: errorDuringRun?.message ?? 'Computer-use session did not return a report.',
        });
      } else {
        report.runId = runId;
        report.taskId = task.id;
        report.startedAt = report.startedAt ?? startedAt.toISOString();
        report.finishedAt = finishedAt.toISOString();
        report.links = {
          ...(report.links ?? {}),
          traceUrl: tracePath,
          screenshotsGalleryUrl: handle.screenshotDir,
          rawTranscriptUrl: responsesPath ?? null,
        };
      }

      const priceUsd = this.computePriceUsd(provider.provider, modelUsed, usageTotals);
      report.costs = {
        ...(report.costs ?? {}),
        tokensInput: usageTotals.tokensInput,
        tokensOutput: usageTotals.tokensOutput,
        toolCalls: totalToolCalls,
        durationMs: finishedAt.getTime() - startedAt.getTime(),
        priceUsd,
      };

      if (task.requireFindings && (!report.findings || report.findings.length === 0)) {
        report.findings = [
          this.createPlaceholderFinding(
            initialScreenshot,
            startedAt,
            'No explicit findings were generated by the AI session.',
          ),
        ];
      }

      const reportPath = path.join(handle.artifactDir, 'qa-report.json');
      await writeFile(reportPath, JSON.stringify(report, null, 2), 'utf8');
      const metadataPath = path.join(handle.artifactDir, 'run-metadata.json');
      const metadata = {
        runId,
        taskId: task.id,
        provider: provider.provider,
        startedAt: startedAt.toISOString(),
        finishedAt: finishedAt.toISOString(),
        artifactDir: handle.artifactDir,
        screenshots: handle.screenshots,
        budgets: task.budgets,
        kpiSpec: task.kpiSpec,
        eventsPath: eventsPath ?? null,
        responsesPath: responsesPath ?? null,
        usageTotals,
        totalToolCalls,
        model: modelUsed,
      };
      await writeFile(metadataPath, JSON.stringify(metadata, null, 2), 'utf8');

      const logPath = path.join(handle.artifactDir, 'run-log.json');
      const logEvents = [
        {
          type: 'run_started',
          timestamp: startedAt.toISOString(),
          message: `Run ${runId} created for task ${task.id}`,
        },
        {
          type: report.status === 'passed' ? 'run_completed' : 'run_completed_with_notes',
          timestamp: finishedAt.toISOString(),
          message:
            report.status === 'passed'
              ? 'AI computer-use session completed successfully.'
              : `Run finished with status ${report.status}. ${report.summary}`,
        },
      ];
      if (errorDuringRun) {
        logEvents.push({
          type: 'error',
          timestamp: finishedAt.toISOString(),
          message: errorDuringRun.message,
        });
      }
      await writeFile(logPath, JSON.stringify({ runId, events: logEvents }, null, 2), 'utf8');
      this.runEvents.emit(runId, {
        type: 'status',
        message: `Run ${runId} completed with status ${report.status}`,
        timestamp: finishedAt.toISOString(),
        payload: {
          runStatus: 'completed',
          reportStatus: report.status,
          finishedAt: finishedAt.toISOString(),
          report,
        },
      });
      this.runEvents.complete(runId);

      return {
        report,
        artifacts: {
          screenshots: handle.screenshots,
          traceZipPath: tracePath,
          reportPath,
          metadataPath,
          logsPath: logPath,
          transcriptPath: responsesPath,
          eventsPath,
        },
      };
    } finally {
      await this.workerGateway.stopRun(handle);
    }
  }

  private computePriceUsd(
    provider: AiProvider,
    model: string | null,
    usageTotals: { tokensInput: number; tokensOutput: number },
  ): number {
    if (usageTotals.tokensInput === 0 && usageTotals.tokensOutput === 0) {
      return 0;
    }

    const normalizedModel = (model ?? '').toLowerCase();
    let inputRate = 3;
    let outputRate = 12;

    if (provider === 'anthropic') {
      if (normalizedModel.includes('haiku-4-5')) {
        inputRate = 1;
        outputRate = 5;
      } else if (normalizedModel.includes('sonnet-4-5')) {
        const highInput = usageTotals.tokensInput > 200_000;
        const highOutput = usageTotals.tokensOutput > 200_000;
        inputRate = highInput ? 6 : 3;
        outputRate = highOutput ? 22.5 : 15;
      } else if (normalizedModel.includes('opus')) {
        inputRate = 15;
        outputRate = 75;
      } else {
        inputRate = 3;
        outputRate = 15;
      }
    } else if (provider === 'openai') {
      if (normalizedModel.includes('computer-use')) {
        inputRate = 3;
        outputRate = 12;
      }
    }

    const price =
      (usageTotals.tokensInput / 1_000_000) * inputRate +
      (usageTotals.tokensOutput / 1_000_000) * outputRate;

    return parseFloat(price.toFixed(4));
  }

  private buildFallbackReport(options: {
    runId: string;
    task: TaskSpec;
    startedAt: Date;
    finishedAt: Date;
    initialScreenshot: string;
    tracePath: string;
    reason: string;
  }): QaReport {
    return {
      id: uuidv4(),
      runId: options.runId,
      taskId: options.task.id,
      startedAt: options.startedAt.toISOString(),
      finishedAt: options.finishedAt.toISOString(),
      summary: `Run ended without a structured QAReport: ${options.reason}`,
      status: 'inconclusive',
      findings: [
        this.createPlaceholderFinding(
          options.initialScreenshot,
          options.startedAt,
          options.reason,
        ),
      ],
      kpiTable: [],
      links: {
        traceUrl: options.tracePath,
        screenshotsGalleryUrl: path.dirname(options.initialScreenshot),
        rawTranscriptUrl: null,
      },
      costs: {
        tokensInput: 0,
        tokensOutput: 0,
        toolCalls: 0,
        durationMs: options.finishedAt.getTime() - options.startedAt.getTime(),
        priceUsd: 0,
      },
    };
  }

  private createPlaceholderFinding(
    screenshotRef: string,
    timestamp: Date,
    message: string,
  ): Finding {
    return {
      id: uuidv4(),
      severity: 'info',
      category: 'functional',
      assertion: 'AI session summary',
      expected: 'At least one finding should accompany each run report.',
      observed: message,
      tolerance: null,
      evidence: [
        {
          screenshotRef,
          selector: null,
          time: timestamp.toISOString(),
          networkRequestId: null,
        },
      ],
      suggestedFix: 'Review the AI transcript or rerun the task for more detail.',
      confidence: 0.5,
    };
  }
}
